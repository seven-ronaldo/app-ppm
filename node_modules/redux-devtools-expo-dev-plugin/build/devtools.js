import { evalAction, catchErrors, getActionsArray, getLocalFilter, isFiltered, filterStagedActions, filterState, } from "@redux-devtools/utils";
import { getDevToolsPluginClientAsync, } from "expo/devtools";
import { stringify, parse } from "jsan";
import configureStore from "./configureStore";
function async(fn) {
    setTimeout(fn, 0);
}
function str2array(str) {
    return typeof str === "string"
        ? [str]
        : str && str.length > 0
            ? str
            : undefined;
}
function getRandomId() {
    return Math.random().toString(36).substring(2);
}
class DevToolsEnhancer {
    // eslint-disable-next-line @typescript-eslint/ban-types
    store;
    filters;
    instanceId;
    devToolsPluginClient;
    sendTo;
    instanceName;
    appInstanceId;
    stateSanitizer;
    actionSanitizer;
    isExcess;
    actionCreators;
    isMonitored;
    lastErrorMsg;
    started;
    suppressConnectErrors;
    startOn;
    stopOn;
    sendOn;
    sendOnError;
    channel;
    errorCounts = {};
    lastAction;
    paused;
    locked;
    getInstanceId() {
        if (!this.instanceId) {
            this.instanceId = getRandomId();
        }
        return this.instanceId;
    }
    getLiftedStateRaw() {
        return this.store.liftedStore.getState();
    }
    getLiftedState() {
        return filterStagedActions(this.getLiftedStateRaw(), this.filters);
    }
    send = () => {
        if (!this.sendTo) {
            console.log("redux-devtools-expo-dev-plugin: Cannot send message from sendOn or sendOnError without a sendTo URL being provided");
            return;
        }
        try {
            fetch(this.sendTo, {
                method: "POST",
                headers: {
                    "content-type": "application/json",
                },
                body: JSON.stringify({
                    type: "STATE",
                    id: this.getInstanceId(),
                    name: this.instanceName,
                    payload: stringify(this.getLiftedState()),
                }),
            }).catch(function (err) {
                console.log(err);
            });
        }
        catch (err) {
            console.log(err);
        }
    };
    relay(type, state, action, nextActionId) {
        const message = {
            type,
            id: this.getInstanceId(),
            name: this.instanceName,
            instanceId: this.appInstanceId,
        };
        if (state) {
            message.payload =
                type === "ERROR"
                    ? state
                    : stringify(filterState(state, type, this.filters, this.stateSanitizer, this.actionSanitizer, nextActionId));
        }
        if (type === "ACTION") {
            message.action = stringify(!this.actionSanitizer
                ? action
                : this.actionSanitizer(action.action, nextActionId - 1));
            message.isExcess = this.isExcess;
            message.nextActionId = nextActionId;
        }
        else if (action) {
            message.action = action;
        }
        this.devToolsPluginClient?.sendMessage("log", message);
    }
    dispatchRemotely(action) {
        try {
            const result = evalAction(action, this.actionCreators);
            this.store.dispatch(result);
        }
        catch (e) {
            this.relay("ERROR", e.message);
        }
    }
    handleMessages = (message) => {
        if (message.type === "IMPORT" ||
            (message.type === "SYNC" &&
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                this.instanceId &&
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                message.id !== this.instanceId)) {
            this.store.liftedStore.dispatch({
                type: "IMPORT_STATE",
                // eslint-disable-next-line @typescript-eslint/ban-types
                nextLiftedState: parse(message.state),
            });
        }
        else if (message.type === "UPDATE") {
            this.relay("STATE", this.getLiftedState());
        }
        else if (message.type === "START") {
            this.isMonitored = true;
            if (typeof this.actionCreators === "function")
                this.actionCreators = this.actionCreators();
            this.relay("STATE", this.getLiftedState(), this.actionCreators);
        }
        else if (message.type === "STOP" || message.type === "DISCONNECTED") {
            this.isMonitored = false;
            this.relay("STOP");
        }
        else if (message.type === "ACTION") {
            this.dispatchRemotely(message.action);
        }
        else if (message.type === "DISPATCH") {
            this.store.liftedStore.dispatch(message.action);
        }
    };
    sendError = (errorAction) => {
        // Prevent flooding
        if (errorAction.message && errorAction.message === this.lastErrorMsg)
            return;
        this.lastErrorMsg = errorAction.message;
        async(() => {
            this.store.dispatch(errorAction);
            if (!this.started)
                this.send();
        });
    };
    init(options) {
        this.instanceName = options.name;
        this.appInstanceId = getRandomId();
        const { blacklist, whitelist, denylist, allowlist } = options.filters || {};
        this.filters = getLocalFilter({
            actionsDenylist: denylist ??
                options.actionsDenylist ??
                blacklist ??
                options.actionsBlacklist,
            actionsAllowlist: allowlist ??
                options.actionsAllowlist ??
                whitelist ??
                options.actionsWhitelist,
        });
        this.suppressConnectErrors =
            options.suppressConnectErrors !== undefined
                ? options.suppressConnectErrors
                : true;
        this.startOn = str2array(options.startOn);
        this.stopOn = str2array(options.stopOn);
        this.sendOn = str2array(options.sendOn);
        this.sendOnError = options.sendOnError;
        this.sendTo = options.sendTo;
        if (this.sendOnError === 1)
            catchErrors(this.sendError);
        if (options.actionCreators)
            this.actionCreators = () => getActionsArray(options.actionCreators);
        this.stateSanitizer = options.stateSanitizer;
        this.actionSanitizer = options.actionSanitizer;
    }
    stop = async () => {
        this.started = false;
        this.isMonitored = false;
        if (!this.devToolsPluginClient)
            return;
        await this.devToolsPluginClient.closeAsync();
        this.devToolsPluginClient = undefined;
    };
    start = () => {
        if (this.started)
            return;
        (async () => {
            try {
                this.devToolsPluginClient = await getDevToolsPluginClientAsync("redux-devtools-expo-dev-plugin");
                this.devToolsPluginClient.addMessageListener("respond", (data) => {
                    this.handleMessages(data);
                });
                this.started = true;
                this.relay("START");
            }
            catch (e) {
                console.warn("Failed to setup Expo dev plugin client from Redux DevTools enhancer: " +
                    e.toString());
                this.stop();
            }
        })();
    };
    checkForReducerErrors = (liftedState = this.getLiftedStateRaw()) => {
        if (liftedState.computedStates[liftedState.currentStateIndex].error) {
            if (this.started)
                this.relay("STATE", filterStagedActions(liftedState, this.filters));
            else
                this.send();
            return true;
        }
        return false;
    };
    // eslint-disable-next-line @typescript-eslint/ban-types
    monitorReducer = (state = {}, action) => {
        this.lastAction = action.type;
        if (!this.started && this.sendOnError === 2 && this.store.liftedStore)
            async(this.checkForReducerErrors);
        else if (action.action) {
            if (this.startOn &&
                !this.started &&
                this.startOn.indexOf(action.action.type) !== -1)
                async(this.start);
            else if (this.stopOn &&
                this.started &&
                this.stopOn.indexOf(action.action.type) !== -1)
                async(this.stop);
            else if (this.sendOn &&
                !this.started &&
                this.sendOn.indexOf(action.action.type) !== -1)
                async(this.send);
        }
        return state;
    };
    // eslint-disable-next-line @typescript-eslint/ban-types
    handleChange(state, liftedState, maxAge) {
        if (this.checkForReducerErrors(liftedState))
            return;
        if (this.lastAction === "PERFORM_ACTION") {
            const nextActionId = liftedState.nextActionId;
            const liftedAction = liftedState.actionsById[nextActionId - 1];
            if (isFiltered(liftedAction.action, this.filters))
                return;
            this.relay("ACTION", state, liftedAction, nextActionId);
            if (!this.isExcess && maxAge)
                this.isExcess = liftedState.stagedActionIds.length >= maxAge;
        }
        else {
            if (this.lastAction === "JUMP_TO_STATE")
                return;
            if (this.lastAction === "PAUSE_RECORDING") {
                this.paused = liftedState.isPaused;
            }
            else if (this.lastAction === "LOCK_CHANGES") {
                this.locked = liftedState.isLocked;
            }
            if (this.paused || this.locked) {
                if (this.lastAction)
                    this.lastAction = undefined;
                else
                    return;
            }
            this.relay("STATE", filterStagedActions(liftedState, this.filters));
        }
    }
    enhance = (options = {}) => {
        this.init(options);
        const realtime = typeof options.realtime === "undefined" || options.realtime;
        const maxAge = options.maxAge || 30;
        return ((next) => {
            return (reducer, initialState) => {
                this.store = configureStore(next, this.monitorReducer, {
                    maxAge,
                    trace: options.trace,
                    traceLimit: options.traceLimit,
                    shouldCatchErrors: !!this.sendOnError,
                    shouldHotReload: options.shouldHotReload,
                    shouldRecordChanges: options.shouldRecordChanges,
                    shouldStartLocked: options.shouldStartLocked,
                    pauseActionType: options.pauseActionType || "@@PAUSED",
                })(reducer, initialState);
                if (realtime)
                    this.start();
                this.store.subscribe(() => {
                    if (this.isMonitored)
                        this.handleChange(this.store.getState(), this.getLiftedStateRaw(), maxAge);
                });
                return this.store;
            };
        });
    };
}
export default (options) => new DevToolsEnhancer().enhance(options);
const compose = (options) => (...funcs) => (...args) => {
    const devToolsEnhancer = new DevToolsEnhancer();
    function preEnhancer(createStore) {
        return (reducer, preloadedState) => {
            devToolsEnhancer.store = createStore(reducer, preloadedState);
            return {
                ...devToolsEnhancer.store,
                dispatch: (action) => devToolsEnhancer.locked
                    ? action
                    : devToolsEnhancer.store.dispatch(action),
            };
        };
    }
    return [preEnhancer, ...funcs].reduceRight((composed, f) => f(composed), devToolsEnhancer.enhance(options)(...args));
};
export function composeWithDevTools(...funcs) {
    if (funcs.length === 0) {
        return new DevToolsEnhancer().enhance();
    }
    if (funcs.length === 1 && typeof funcs[0] === "object") {
        return compose(funcs[0]);
    }
    return compose({})(...funcs);
}
//# sourceMappingURL=devtools.js.map